<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <h1>Traversing</h1>

    <h2>Traversing: Nach unten</h2>

    <p>
        Nach unten bewegen wir uns mit Element.querySelector();, Element.querySelectorAll(); und .children;
    </p>

    <section>
        <h3>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector">
                Element.QuerySelector();
            </a>
        </h3>

        <div class="nachbarschaft">
            <ul id="unserHaus">
                Unser Haus
                <li class="wohnzimmer">Unser Wohnzimmer</li>
                <li class="badezimmer">Badezimmer</li>
                <li class="schlafzimmer">Schlafzimmer</li>
                <li class="kueche">Küche</li>
            </ul>

            <hr>
            <ul id="nachbarHaus">
                Nachbars Haus
                <li class="wohnzimmer">Nachbars Wohnzimmer</li>
                <li class="badezimmer">Badezimmer</li>
                <li class="schlafzimmer">Schlafzimmer</li>
                <li class="kueche">Küche</li>
            </ul>
        </div>

        <script>
            const unserHaus = document.querySelector("#unserHaus");
            const nachbarHaus = document.querySelector("#nachbarHaus");

            const unserWohnzimmer = unserHaus.querySelector(".wohnzimmer");
            const nachbarsWohnZimmer = nachbarHaus.querySelector(".wohnzimmer");

            console.log(unserWohnzimmer);
            console.log(nachbarsWohnZimmer);
        </script>
    </section>

    <section>
        <h3>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/children">
                ParentNode.children;
            </a>
        </h3>

        <p>
            Mit dieser methode bekommen wir direkt die kinder eines elementes, also elemente die sich innerhalb eines anderen elementes befinden. Wir kriegen eine Array des types HTMLCollection zurück, die automatisch geupdated wird, wenn sich in einem der elemente etwas ändern.
        </p>

        <ul id="liste">
            <li>Eintrag 1</li>
            <li>Eintrag 2</li>
            <li>Eintrag 3</li>
            <li>Eintrag 4</li>
            <li>Eintrag 5</li>
        </ul>

        <script>
            const liste = document.querySelector("#liste");
            const listenEintraege = liste.children;

            console.log(listenEintraege);
            console.log(listenEintraege[1]);

            listenEintraege[1].innerText = "Veränderter Eintrag";
        </script>
    </section>

    <h2>Traversing: Nach oben</h2>

    <section>
        <h3>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/parentElement">
                Node.parentElement;
            </a>    
        </h3>

        <p>
            Mit dieser methode können wir direkt vom kindelement aus das elternelement selektieren.
        </p>

        <ul id="buecherregal">
            <li id="erstesBuch">Buch 1</li>
            <li id="zweitesBuch">Buch 2</li>
            <li>Buch 3</li>
            <li>Buch 4</li>
            <li>Buch 5</li>
        </ul>

        <script>
            const erstesBuch = document.querySelector("#erstesBuch");
            const zweitesBuch = document.querySelector("#zweitesBuch");
            const regal = zweitesBuch.parentElement;

            console.log(regal);
        </script>
    </section>

    <section>
        <h3>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/closest">
                Element.closest();
            </a>
        </h3>

        <p>
            element.parentElement; ist eine sehr gute methode um eine einzelne ebene nach oben zu kommen, um aber ein element ein paar ebenen höher zu bekommen, gibt es die methode element.closest();, da wir mir dieser methode den nächstgelegenen selektor der zur prüfung passt. 
        </p>

        <i>
            element.closest(); ist ziemlich neu, und wird bisher nicht von jedem browser unterstützt.
        </i>

        <div id="ganzWeitAussen">
            <div id="ziemlichWeitAussen">
                <div id="aussen">
                    <div id="innen">
                        Das innerste Element
                    </div>
                </div>
            </div>
        </div>

        <div id="elternBox" class="box">
            <div id="aeussereBox">
                <div id="mittlereBox">
                    <div id="innersteBox" class="box">
                        Dies ist eine Box
                    </div>
                </div>
            </div>
        </div>

        <script>
            const inneresElement = document.querySelector("#innen");
            const auesseresElement = inneresElement.closest("#ganzWeitAussen");

            console.log(auesseresElement);

            const innersteBox = document.querySelector("#mittlereBox");
            const naechsteBox = innersteBox.closest(".box");

            console.log(naechsteBox);

        </script>
    </section>

    <h2>Traversing: Seitwärts</h2>

    <p>
        Um uns seitwärts zu traversen gibt es verschiedene methoden, zum beispiel element.nextElementSibling(); und element.previousElementSibling();.
    </p>

    <section>
        <h3>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/nextElementSibling">
                element.nextElementSibling;
            </a>
        </h3>

        <p>Mit dieser methode können wir das nächstgelegene element selektieren.</p>

        <ul id="eineKleineListe">
            <li>Eintrag 1</li><li>Eintrag 2</li><li>Eintrag 3</li>
        </ul>

        <script>
            const erstesElement = document.querySelector("#eineKleineListe li");
            const zweitesElement = erstesElement.nextElementSibling;

            console.log(zweitesElement);
        </script>
    </section>

    <section>
        <h3>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/previousElementSibling">
                element.previousElementSibling;
            </a>
        </h3>

        <p>
            mit dieser methode können wir das vorherige element selektieren.
        </p>

        <ul id="nochEineKleineListe">
            <li>Eintrag 1</li><li>Eintrag 2</li><li>Eintrag 3</li>
        </ul>

        <script>
            const zweitesListenElement = document.querySelectorAll("#nochEineKleineListe li")[1];
            const erstesListenElement = zweitesListenElement.previousElementSibling;

            console.log(erstesListenElement);

        </script>
    </section>

    <section>
        <h3>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/matches">
                Element.matches();
            </a>
        </h3>

        <p>
            Diese methode überprüft ob ein element anhand einer selektion das richtige ist und gibt anhand der entscheidung einen boolean zurück.
        </p>

        <ul id="benutzerListe">
            <li>Max</li><li class="admin">James</li><li>Bruce</li><li>Henry</li>
        </ul>

        <script>
            const benutzerListe = document.querySelectorAll("#benutzerListe > li");

            for (let i = 0; i < benutzerListe.length; i++) 
            {
                if(benutzerListe[i].matches(".admin"))
                {
                    console.log("Unser admin heisst " + benutzerListe[i].innerText);
                }
            }
        </script>
    </section>

    <section>
        <h3>Kombination aus element.parentELement();, children und index</h3>

        <ul id="rezepteListe">
            <li>Rezept 1</li>
            <li>Rezept 2</li>
            <li>Rezept 3</li>
            <li>Rezept 4</li>
            <li>Rezept 5</li>
        </ul>

        <script>
            // Wir selektieren das erste element in der liste
            /*
            <ul id="rezepteListe">
                <li>Rezept 1</li> <-------- SELEKTIERT
                <li>Rezept 2</li>
                <li>Rezept 3</li>
                <li>Rezept 4</li>
                <li>Rezept 5</li>
            </ul>
            */
            const erstesRezept = document.querySelector("#rezepteListe li");

            // Wir holen uns das elternElement (die liste)
            /*
            <ul id="rezepteListe"> <-------- SELEKTIERT
                ...
            </ul>
            */
            const rezepteListe = erstesRezept.parentElement;

            // Wir holen uns die einträge der liste
             /*
            ...
                <li>Rezept 1</li>
                <li>Rezept 2</li>
                <li>Rezept 3</li>
                <li>Rezept 4</li>
                <li>Rezept 5</li>
            ...
            */
            const alleRezepte = rezepteListe.children;

            // Wir holen uns das vierte element der liste
            /*
            ...
                <li>Rezept 1</li>
                <li>Rezept 2</li>
                <li>Rezept 3</li>
                <li>Rezept 4</li><-------- SELEKTIERT
                <li>Rezept 5</li>
            ...
            */
            const viertesRezept = alleRezepte[3];

            // Jetzt geben wir das vierte element aus
            console.log(viertesRezept); // <li>Rezept 4 </li>

            // Das ganze als "chained method" ... oder kette:
            const viertesRezeptAlsKette = erstesRezept.parentElement.children[3];
            console.log(viertesRezeptAlsKette);
        </script>
    </section>

</body>
</html>